<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Deluxe</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #1a1a1a;
            --text-color: #fff;
            --accent-color: #ff0055;
            --border-color: #333;
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #game-layout {
            display: flex;
            gap: 15px;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background-color: rgba(20, 20, 20, 0.95);
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
            align-items: flex-start;
            position: relative;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
        }

        /* --- MENÚ DE INICIO --- */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
        }

        h1 {
            color: #ff0055;
            text-shadow: 3px 3px 0 #00e5ff;
            font-size: 2rem;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
        }

        .menu-btn {
            background: #222;
            color: #fff;
            border: 2px solid #fff;
            padding: 15px 20px;
            font-family: inherit;
            font-size: 0.8rem;
            margin: 10px;
            cursor: pointer;
            width: 200px;
            text-transform: uppercase;
            transition: 0.2s;
        }

        .menu-btn:hover { transform: scale(1.1); }
        .btn-easy { border-color: #0DFF72; color: #0DFF72; }
        .btn-easy:hover { background: #0DFF72; color: #000; }

        .btn-normal { border-color: #FFFF00; color: #FFFF00; }
        .btn-normal:hover { background: #FFFF00; color: #000; }

        .btn-hard { border-color: #FF0055; color: #FF0055; }
        .btn-hard:hover { background: #FF0055; color: #000; }

        /* --- RESTO DEL JUEGO --- */
        .canvas-container {
            position: relative;
            border: 2px solid #444;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            background-color: #000;
            image-rendering: pixelated;
        }

        #side-panel {
            display: flex;
            flex-direction: column;
            width: 120px;
            gap: 15px;
        }

        .panel-box {
            background: var(--panel-bg);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #444;
        }

        .label {
            font-size: 0.5em;
            color: #aaa;
            margin-bottom: 8px;
            display: block;
            text-transform: uppercase;
        }

        .value { font-size: 0.8em; color: #fff; }

        .mini-canvas {
            width: 80px; height: 80px;
            margin: 0 auto;
            display: block;
            image-rendering: pixelated;
        }

        #sound-btn {
            background: transparent; border: 1px solid #444; color: #666;
            font-size: 0.5em; padding: 8px; cursor: pointer; font-family: inherit;
            width: 100%; transition: all 0.2s;
        }
        #sound-btn:hover { background: #222; }
        #sound-btn.active { color: #0f0; border-color: #0f0; box-shadow: 0 0 10px rgba(0,255,0,0.2); }

        #mobile-controls {
            display: none;
            position: absolute; bottom: -160px; left: 50%;
            transform: translateX(-50%);
            gap: 15px; width: 300px;
            justify-content: center; flex-wrap: wrap;
        }

        .btn {
            background: #333; border: 2px solid #555; border-radius: 10px;
            width: 50px; height: 50px; color: white;
            font-size: 1.2rem; display: flex; justify-content: center; align-items: center;
            cursor: pointer;
        }
        .btn:active { background: #555; transform: scale(0.95); }
        .btn-big { width: 60px; height: 60px; background: #220011; border-color: #ff0055; }

        #paused-overlay {
            display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); color: #fff;
            justify-content: center; align-items: center; font-size: 1.5em; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-layout">
            <div id="menu-overlay">
                <h1>TETRIS<br>JS</h1>
                <button class="menu-btn btn-easy" onclick="startGame('easy')">FÁCIL</button>
                <button class="menu-btn btn-normal" onclick="startGame('normal')">NORMAL</button>
                <button class="menu-btn btn-hard" onclick="startGame('hard')">DIFÍCIL</button>
            </div>

            <div id="paused-overlay">PAUSA</div>

            <div id="side-panel" style="width: 100px;">
                <div class="panel-box"><span class="label">HOLD (C)</span><canvas id="hold-piece" class="mini-canvas" width="80" height="80"></canvas></div>
                <div class="panel-box"><span class="label">Puntos</span><div id="score" class="value">0</div></div>
                <div class="panel-box"><span class="label">Nivel</span><div id="level" class="value">1</div></div>
                <button id="sound-btn">♫ SONIDO</button>
            </div>

            <div class="canvas-container"><canvas id="tetris" width="240" height="400"></canvas></div>

            <div id="side-panel" style="width: 100px;">
                <div class="panel-box"><span class="label">NEXT</span><canvas id="next-piece" class="mini-canvas" width="80" height="80"></canvas></div>
                <div class="panel-box"><span class="label">Récord</span><div id="highscore" class="value">0</div></div>
                <div class="panel-box" style="background:transparent; border:none;">
                     <p class="label" style="line-height:1.6; text-align:left;">← → Mover<br>↑ Rotar<br>↓ Bajar<br>Espacio: Caer</p>
                </div>
            </div>

            <div id="mobile-controls">
                <div class="btn" id="btn-left">←</div><div class="btn" id="btn-down">↓</div><div class="btn" id="btn-right">→</div>
                <div class="btn btn-big" id="btn-rotate">↻</div><div class="btn btn-big" id="btn-drop">⚡</div><div class="btn" id="btn-hold">H</div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN DE DIFICULTAD ---
        let difficulty = 'normal';
        let gameRunning = false;

        function startGame(selectedDiff) {
            difficulty = selectedDiff;
            document.getElementById('menu-overlay').style.display = 'none';

            // Activar Audio
            if(audioCtx.state === 'suspended') audioCtx.resume();

            // Activar Sonido automáticamente
            soundEnabled = true;
            document.getElementById('sound-btn').classList.add('active');
            startMusic();

            // Resetear y Arrancar
            gameRunning = true;
            playerReset();
            updateScore();
            update();
        }

        // --- ESCALADO ---
        function resizeGame() {
            const gameLayout = document.getElementById('game-layout');
            const windowWidth = window.innerWidth; const windowHeight = window.innerHeight;
            let scale = Math.min(windowWidth / 520, windowHeight / 480) * 0.9;
            gameLayout.style.transform = `scale(${scale})`;
            const isMobile = windowWidth < 768;
            document.getElementById('mobile-controls').style.display = isMobile ? 'flex' : 'none';
            gameLayout.style.marginBottom = isMobile ? "100px" : "0";
        }
        window.addEventListener('resize', resizeGame); window.addEventListener('load', resizeGame);

        const canvas = document.getElementById('tetris'); const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece'); const nextContext = nextCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-piece'); const holdContext = holdCanvas.getContext('2d');
        context.scale(20, 20); nextContext.scale(20, 20); holdContext.scale(20, 20);

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = false;
        let musicPlaying = false;
        let noteIndex = 0; let nextNoteTime = 0; let timerID = null;

        const N = { B3:246.94, C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88, C5:523.25, D5:587.33, E5:659.25, Gs4:415.30 };
        const melody = [
            {n:N.E5,d:0.5},{n:N.B4,d:0.25},{n:N.C5,d:0.25},{n:N.D5,d:0.5},{n:N.C5,d:0.25},{n:N.B4,d:0.25},
            {n:N.A4,d:0.5},{n:N.A4,d:0.25},{n:N.C5,d:0.25},{n:N.E5,d:0.5},{n:N.D5,d:0.25},{n:N.C5,d:0.25},
            {n:N.B4,d:0.75},{n:N.C5,d:0.25},{n:N.D5,d:0.5},{n:N.E5,d:0.5},{n:N.C5,d:0.5},{n:N.A4,d:0.5},{n:N.A4,d:0.5},{n:0,d:0.5},
            {n:N.D5,d:0.5},{n:N.F4,d:0.25},{n:N.A4,d:0.25},{n:N.D5,d:0.5},{n:N.C5,d:0.25},{n:N.B4,d:0.25},
            {n:N.C5,d:0.5},{n:N.E4,d:0.25},{n:N.C5,d:0.25},{n:N.E5,d:0.5},{n:N.D5,d:0.25},{n:N.C5,d:0.25},
            {n:N.B4,d:0.5},{n:N.B4,d:0.25},{n:N.C5,d:0.25},{n:N.D5,d:0.5},{n:N.E5,d:0.5},
            {n:N.C5,d:0.5},{n:N.A4,d:0.5},{n:N.A4,d:0.5},{n:0,d:0.5}
        ];
        const tempo = 1.1;

        function scheduler() {
            if (!soundEnabled) return;
            while (nextNoteTime < audioCtx.currentTime + 0.1) {
                playNote(melody[noteIndex]);
                nextNoteTime += melody[noteIndex].d * 0.4 * tempo;
                noteIndex = (noteIndex + 1) % melody.length;
            }
            timerID = window.setTimeout(scheduler, 25.0);
        }

        function playNote(note) {
            if (note.n === 0) return;
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'square'; osc.frequency.value = note.n;
            gain.gain.value = 0.15; gain.gain.exponentialRampToValueAtTime(0.001, nextNoteTime + (note.d * 0.3));
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(nextNoteTime); osc.stop(nextNoteTime + (note.d * 0.4));
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-btn');
            if (soundEnabled) { btn.classList.add('active'); if(audioCtx.state === 'suspended') audioCtx.resume(); startMusic(); }
            else { btn.classList.remove('active'); stopMusic(); }
        }
        function startMusic() { if (!musicPlaying) { noteIndex = 0; nextNoteTime = audioCtx.currentTime; scheduler(); musicPlaying = true; } }
        function stopMusic() { window.clearTimeout(timerID); musicPlaying = false; }

        function playSfx(type) {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
            osc.connect(gainNode); gainNode.connect(audioCtx.destination); const now = audioCtx.currentTime;

            if (type === 'move') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now);
                gainNode.gain.setValueAtTime(0.15, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'rotate') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                gainNode.gain.setValueAtTime(0.15, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'drop') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now);
                gainNode.gain.setValueAtTime(0.25, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'clear') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
        }
        document.getElementById('sound-btn').addEventListener('click', toggleSound);

        // --- JUEGO ---
        let particles = [];
        function createParticles(x, y, color) { for (let i = 0; i < 8; i++) particles.push({ x: x + 0.5, y: y + 0.5, vx: (Math.random() - 0.5) * 0.6, vy: (Math.random() - 0.5) * 0.6, life: 1.0, color: color }); }
        function drawParticles() {
            particles.forEach((p, index) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                if (p.life <= 0) particles.splice(index, 1);
                else { context.globalAlpha = p.life; context.fillStyle = p.color; context.fillRect(p.x, p.y, 0.4, 0.4); context.globalAlpha = 1; }
            });
        }

        function arenaSweep() {
            let rowCount = 1;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) if (arena[y][x] === 0) continue outer;
                const rowColor = colors[arena[y][Math.floor(Math.random() * arena[0].length)]];
                for (let x = 0; x < arena[0].length; x++) createParticles(x, y, rowColor);
                const row = arena.splice(y, 1)[0].fill(0); arena.unshift(row);
                ++y; player.score += rowCount * 10; player.lines++; rowCount *= 2; playSfx('clear');
            }
            player.level = Math.floor(player.lines / 10) + 1;
            setDropInterval(); // Recalcular velocidad
        }

        // --- LÓGICA DE VELOCIDAD POR DIFICULTAD ---
        function setDropInterval() {
            let base = 1000;
            let decrease = 50;

            if (difficulty === 'easy') {
                base = 1000; decrease = 20; // Baja muy lento
            } else if (difficulty === 'normal') {
                base = 1000; decrease = 50; // Baja normal
            } else if (difficulty === 'hard') {
                base = 700; decrease = 80; // Empieza rápido, baja violentamente
            }

            dropInterval = Math.max(50, base - (player.level * decrease));
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) for (let x = 0; x < m[y].length; ++x)
                if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
            return false;
        }

        function createPiece(type) {
            if (type === 'I') return [[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0]];
            if (type === 'L') return [[0, 2, 0],[0, 2, 0],[0, 2, 2]];
            if (type === 'J') return [[0, 3, 0],[0, 3, 0],[3, 3, 0]];
            if (type === 'O') return [[4, 4],[4, 4]];
            if (type === 'Z') return [[5, 5, 0],[0, 5, 5],[0, 0, 0]];
            if (type === 'S') return [[0, 6, 6],[6, 6, 0],[0, 0, 0]];
            if (type === 'T') return [[0, 7, 0],[7, 7, 7],[0, 0, 0]];
        }

        function drawMatrix(matrix, offset, ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = colors[value]; ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.lineWidth = 0.05; ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                    }
                });
            });
        }

        function draw() {
            context.fillStyle = '#000'; context.fillRect(0, 0, canvas.width, canvas.height);
            drawMatrix(arena, {x: 0, y: 0}, context);
            const ghostPos = {...player.pos};
            while (!collide(arena, {matrix: player.matrix, pos: ghostPos})) ghostPos.y++;
            ghostPos.y--;
            context.globalAlpha = 0.2; drawMatrix(player.matrix, ghostPos, context); context.globalAlpha = 1;
            drawMatrix(player.matrix, player.pos, context);
            drawParticles();
        }

        function drawMini(ctx, matrix) {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, 4, 4);
            if (matrix) { const offset = {x: (4 - matrix[0].length) / 2, y: (4 - matrix.length) / 2}; drawMatrix(matrix, offset, ctx); }
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => row.forEach((value, x) => { if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value; }));
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) { player.pos.y--; merge(arena, player); playSfx('drop'); arenaSweep(); playerReset(); updateScore(); }
            dropCounter = 0;
        }

        function playerHardDrop() {
            while(!collide(arena, player)) player.pos.y++;
            player.pos.y--; merge(arena, player); playSfx('drop'); arenaSweep(); playerReset(); updateScore(); dropCounter = 0;
        }

        function playerMove(dir) {
            player.pos.x += dir; if (collide(arena, player)) player.pos.x -= dir; else playSfx('move');
        }

        function playerRotate(dir) {
            const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; }
            }
            playSfx('rotate');
        }

        function playerHold() {
            if (!canHold) return;
            if (player.hold === null) { player.hold = player.matrix; playerReset(true); }
            else { const temp = player.matrix; player.matrix = player.hold; player.hold = temp; player.pos.y = 0; player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0); }
            canHold = false; playSfx('move'); drawMini(holdContext, player.hold);
        }

        function playerReset(fromHold = false) {
            if (!fromHold) {
                if (player.next === null) player.next = createPiece('ILJOTSZ'[Math.random() * 7 | 0]);
                player.matrix = player.next; player.next = createPiece('ILJOTSZ'[Math.random() * 7 | 0]);
            }
            player.pos.y = 0; player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            canHold = true; drawMini(nextContext, player.next);
            if (collide(arena, player)) {
                // GAME OVER - Reiniciar al menú
                arena.forEach(row => row.fill(0));
                player.score = 0; player.lines = 0; player.level = 1; player.hold = null;
                gameRunning = false;
                document.getElementById('menu-overlay').style.display = 'flex'; // Mostrar menú
                stopMusic(); // Parar música
                drawMini(holdContext, null); updateScore();
            }
        }

        let dropCounter = 0; let dropInterval = 1000; let lastTime = 0; let canHold = true;

        function update(time = 0) {
            if(!gameRunning) return; // Si estamos en el menú, no actualizar
            const deltaTime = time - lastTime; lastTime = time; dropCounter += deltaTime;
            if (dropCounter > dropInterval) playerDrop();
            draw(); requestAnimationFrame(update);
        }

        function updateScore() {
            document.getElementById('score').innerText = player.score; document.getElementById('level').innerText = player.level;
            let highscore = localStorage.getItem('tetris_highscore') || 0;
            if (player.score > highscore) { highscore = player.score; localStorage.setItem('tetris_highscore', player.score); }
            document.getElementById('highscore').innerText = highscore;
        }

        const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
        const arena = createMatrix(12, 20);
        const player = { pos: {x: 0, y: 0}, matrix: null, next: null, hold: null, score: 0, lines: 0, level: 1 };
        function createMatrix(w, h) { const matrix = []; while (h--) matrix.push(new Array(w).fill(0)); return matrix; }

        document.addEventListener('keydown', event => {
            if(!gameRunning) return;
            if (event.keyCode === 37) playerMove(-1); else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop(); else if (event.keyCode === 81) playerRotate(-1);
            else if (event.keyCode === 38 || event.keyCode === 87) playerRotate(1);
            else if (event.keyCode === 67) playerHold();
            else if (event.keyCode === 32) { event.preventDefault(); playerHardDrop(); }
        });

        document.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => { if(audioCtx.state === 'suspended') audioCtx.resume(); }));
        document.addEventListener('dblclick', e => e.preventDefault(), { passive: false });

        document.getElementById('btn-left').addEventListener('click', () => playerMove(-1));
        document.getElementById('btn-right').addEventListener('click', () => playerMove(1));
        document.getElementById('btn-down').addEventListener('click', () => playerDrop());
        document.getElementById('btn-rotate').addEventListener('click', () => playerRotate(1));
        document.getElementById('btn-drop').addEventListener('click', () => playerHardDrop());
        document.getElementById('btn-hold').addEventListener('click', () => playerHold());

        if (localStorage.getItem('tetris_highscore')) document.getElementById('highscore').innerText = localStorage.getItem('tetris_highscore');

        // Inicialización solo visual, el juego arranca con el menú
        playerReset(); updateScore(); draw(); resizeGame();
    </script>
</body>
</html>